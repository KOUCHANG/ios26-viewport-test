<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS 26 Viewport Horizontal Comparison</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <main>
        <section class="intro">
            <div id="commit-hash">commit: 8491dc9</div>
            <h1>iOS 26 ビューポート単位 比較デモ</h1>
            <p>下にスクロールして、ブラウザのアドレスバーの表示/非表示を切り替えてください。<br>
            各カラムはそれぞれ <code>100vh</code> / <code>100lvh</code> / <code>100dvh</code> を使って高さを決めています。</p>
            <p>右上の数値は実際のピクセル高さおよびビューポート API の値です。iOS 26 での挙動を観察してください。</p>
        </section>

        <div class="container">
            <div class="panel-simple">
                <h2>Fixed bar behavior test</h2>
                <p>下の固定バー内のテキストボックスをタップして、キーボード出現時の位置の変化を確認してください。</p>
                <p>このページは固定バーの挙動に集中するため、vh/lvh/dvh の比較要素は削除しました。</p>
            </div>
        </div>


        <!-- fixed bottom bar for keyboard testing (moved to body root for iOS fixed behavior) -->
        <div class="scroll-filler">
            <p>↓ スクロールしてアドレスバーの表示/非表示を切り替えてください ↓</p>
        </div>
    </main>

    <aside class="status">
        <h3>ビューポート情報</h3>
        <div>window.innerHeight: <strong id="innerH">--</strong>px</div>
        <div>visualViewport.height: <strong id="vviewH">--</strong>px</div>
        <div>visualViewport.offsetTop: <strong id="vviewTop">--</strong>px</div>
    </aside>

    <div id="fixed-bar" role="dialog" aria-label="固定バー">
        <div class="input-wrap">
            <input id="test-input" type="text" placeholder="ここをタップしてキーボードを出してみてください" autocomplete="off">
        </div>
    </div>

    <script>
        // ヘルパー: DOM を更新して各パネルとオーバーレイの位置・高さを表示/調整
        (function () {
            const panels = Array.from(document.querySelectorAll('.column'));
            // overlays will be looked up at runtime inside refreshAll
            let overlaysRoot = null;
            let overlays = {};

            function readViewport() {
                const innerH = window.innerHeight || 0;
                const clientH = document.documentElement.clientHeight || 0;
                const vview = window.visualViewport;
                const vH = vview ? Math.round(vview.height) : 'n/a';
                const vTop = vview ? Math.round(vview.offsetTop) : 'n/a';
                document.getElementById('innerH').textContent = innerH;
                document.getElementById('clientH').textContent = clientH;
                document.getElementById('vviewH').textContent = vH;
                document.getElementById('vviewTop').textContent = vTop;
                return {innerH, clientH, vH, vTop, vview};
            }

            function updatePanels(vinfo) {
                // Set heights explicitly only on mobile or platforms with unstable CSS viewport units.
                const {innerH, vH, vview} = vinfo;
                const visualH = (vview && vview.height) ? vview.height : innerH;
                const lvh = Math.max(innerH, visualH);

                // Detect mobile / small-screen environments; use JS sizing when viewport is narrow or touch device
                const ua = navigator.userAgent || '';
                const isMobileUA = /iP(hone|ad|od)|Android/.test(ua) && !/Windows/.test(ua);
                const isTouch = !!(navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
                const needsJsSizing = (window.innerWidth <= 800) || isMobileUA || (isTouch && window.innerWidth <= 1024);

                if (needsJsSizing) {
                    panels.forEach((panel) => {
                        const unit = panel.getAttribute('data-unit');
                        if (unit === 'vh') {
                            panel.style.height = innerH + 'px';
                        } else if (unit === 'lvh') {
                            panel.style.height = lvh + 'px';
                        } else if (unit === 'dvh') {
                            panel.style.height = Math.round(visualH) + 'px';
                        }
                        const elemHeight = panel.offsetHeight;
                        const rectH = Math.round(panel.getBoundingClientRect().height);
                        panel.querySelector('.elem-height').textContent = elemHeight;
                        panel.querySelector('.rect-height').textContent = rectH;
                    });
                } else {
                    // Desktop browsers: prefer CSS (clear any JS-set heights)
                    panels.forEach((panel) => {
                        panel.style.height = '';
                        const elemHeight = panel.offsetHeight;
                        const rectH = Math.round(panel.getBoundingClientRect().height);
                        panel.querySelector('.elem-height').textContent = elemHeight;
                        panel.querySelector('.rect-height').textContent = rectH;
                    });
                }
            }

            function updateOverlays(vinfo) {
                const {vview} = vinfo;
                const safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom')) || 0;
                const container = document.querySelector('.container');
                const containerRect = container.getBoundingClientRect();
                panels.forEach((panel, idx) => {
                    const unit = panel.getAttribute('data-unit');
                    const overlay = overlays[unit];
                    if (!overlay) return;
                    // compute left relative to viewport using container scroll and panel.offsetLeft
                    const offsetLeft = panel.offsetLeft || 0;
                    const left = Math.round(containerRect.left + offsetLeft - (container.scrollLeft || 0));
                    const width = Math.min(panel.offsetWidth || panel.getBoundingClientRect().width || window.innerWidth, window.innerWidth);
                    overlay.style.left = Math.max(0, left) + 'px';
                    overlay.style.width = Math.max(80, width) + 'px';
                    overlay.style.display = 'block';
                });
                // compute bottom gap (space occupied by browser UI)
                const bottomUI = vview ? Math.max(0, Math.round(window.innerHeight - (vview.offsetTop + vview.height))) : 0;
                const bottomValue = (bottomUI + (window.safeAreaInsetBottom || safeBottom));
                Object.values(overlays).forEach(o => { if (o) o.style.bottom = bottomValue + 'px'; });
            }

            // ヘルパー: 固定バーを visualViewport に追従させる簡易スクリプト
            (function () {
                const bar = document.getElementById('fixed-bar');
                let rafId = null;
                function computeBottom() {
                    const vview = window.visualViewport;
                    const safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom')) || 0;
                    // If visualViewport is available, compute keyboard/overlay height as the difference
                    if (vview) {
                        const viewportBottomGap = Math.max(0, Math.round(window.innerHeight - (vview.offsetTop + vview.height)));
                        // If keyboard is open, gap will be relatively large. Add extra padding to avoid URL pill overlap.
                        const extraPad = viewportBottomGap > 80 ? 36 : 0; // larger extra when keyboard present to avoid URL pill
                        return viewportBottomGap + (window.safeAreaInsetBottom || safeBottom) + extraPad;
                    }
                    // Fallback: no visualViewport -> rely on safe area only
                    return (window.safeAreaInsetBottom || safeBottom);
                }

                function applyBottom() {
                    if (!bar) return;
                    const bottomValue = computeBottom();
                    bar.style.bottom = bottomValue + 'px';
                    // toggle class for small visual adjustments
                    const keyboardLikely = bottomValue > 80; // heuristic
                    bar.classList.toggle('keyboard-open', keyboardLikely);
                    // If still likely overlapping (URL pill), apply stronger lift
                    if (keyboardLikely) {
                        // compute a lift height based on bottomValue (cap it)
                        const liftHeight = Math.min(80, bottomValue + 24);
                        bar.style.setProperty('--lift-y', -(liftHeight) + 'px');
                        bar.classList.toggle('lifted', true);
                    } else {
                        bar.classList.toggle('lifted', false);
                        bar.style.removeProperty('--lift-y');
                    }
                }

                function startStrongUpdate(duration = 800) {
                    const start = performance.now();
                    if (rafId) cancelAnimationFrame(rafId);
                    function loop(now) {
                        applyBottom();
                        if (now - start < duration) {
                            rafId = requestAnimationFrame(loop);
                        } else {
                            rafId = null;
                        }
                    }
                    rafId = requestAnimationFrame(loop);
                }

                // events
                window.addEventListener('resize', applyBottom);
                window.addEventListener('orientationchange', () => { applyBottom(); startStrongUpdate(1000); });
                window.addEventListener('scroll', applyBottom);
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', () => { applyBottom(); startStrongUpdate(1000); });
                    window.visualViewport.addEventListener('scroll', applyBottom);
                }

                // focus/touch: when input gains focus, keep updating while keyboard animates
                const input = document.getElementById('test-input');
                if (input) {
                    input.addEventListener('focus', () => { applyBottom(); startStrongUpdate(1200); });
                    input.addEventListener('blur', () => { applyBottom(); });
                    // touchstart on input area should also trigger update
                    input.addEventListener('touchstart', () => { applyBottom(); startStrongUpdate(800); });
                    // ensure input is scrolled into view on focus (helps when URL pill overlaps)
                    input.addEventListener('focus', () => {
                        setTimeout(() => {
                            try { input.scrollIntoView({ block: 'center', behavior: 'smooth' }); } catch (e) { /* ignore */ }
                        }, 250);
                    });
                }

                // initial
                applyBottom();
                setTimeout(applyBottom, 200);
            })();
        })();