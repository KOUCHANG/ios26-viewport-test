<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS 26 Viewport Horizontal Comparison</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <main>
        <section class="intro">
            <h1>iOS 26 ビューポート単位 比較デモ</h1>
            <p>下にスクロールして、ブラウザのアドレスバーの表示/非表示を切り替えてください。<br>
            各カラムはそれぞれ <code>100vh</code> / <code>100lvh</code> / <code>100dvh</code> を使って高さを決めています。</p>
            <p>右上の数値は実際のピクセル高さおよびビューポート API の値です。iOS 26 での挙動を観察してください。</p>
        </section>

        <div class="container">
            <div class="column vh-unit" data-unit="vh">
                <div class="panel-body">
                    <div class="panel-header">100vh</div>
                    <div class="panel-note">従来のビューポート高さ (vh)</div>
                    <div class="metrics">
                        <div>要素高さ: <strong><span class="elem-height">--</span>px</strong></div>
                        <div>getBoundingClientRect: <strong><span class="rect-height">--</span>px</strong></div>
                    </div>
                </div>
            </div>

            <div class="column lvh-unit" data-unit="lvh">
                <div class="panel-body">
                    <div class="panel-header">100lvh</div>
                    <div class="panel-note">ラージ・ビューポート高さ (lvh)</div>
                    <div class="metrics">
                        <div>要素高さ: <strong><span class="elem-height">--</span>px</strong></div>
                        <div>getBoundingClientRect: <strong><span class="rect-height">--</span>px</strong></div>
                    </div>
                </div>
            </div>

            <div class="column dvh-unit" data-unit="dvh">
                <div class="panel-body">
                    <div class="panel-header">100dvh</div>
                    <div class="panel-note">ダイナミック・ビューポート高さ (dvh)</div>
                    <div class="metrics">
                        <div>要素高さ: <strong><span class="elem-height">--</span>px</strong></div>
                        <div>getBoundingClientRect: <strong><span class="rect-height">--</span>px</strong></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 固定オーバーレイ（アドレスバー上に見える予定の領域を再現） -->
        <div id="overlays">
            <div class="overlay overlay-vh">固定バー (上部・vh)</div>
            <div class="overlay overlay-lvh">固定バー (上部・lvh)</div>
            <div class="overlay overlay-dvh">固定バー (上部・dvh)</div>
        </div>

        <div class="scroll-filler">
            <p>↓ スクロールしてアドレスバーの表示/非表示を切り替えてください ↓</p>
        </div>
    </main>

    <aside class="status">
        <h3>ビューポート情報</h3>
        <div>window.innerHeight: <strong id="innerH">--</strong>px</div>
        <div>document.documentElement.clientHeight: <strong id="clientH">--</strong>px</div>
        <div>visualViewport.height: <strong id="vviewH">--</strong>px</div>
        <div>visualViewport.offsetTop: <strong id="vviewTop">--</strong>px</div>
    </aside>

    <script>
        // ヘルパー: DOM を更新して各パネルとオーバーレイの位置・高さを表示/調整
        (function () {
            const panels = Array.from(document.querySelectorAll('.column'));
            const overlays = {
                vh: document.querySelector('.overlay-vh'),
                lvh: document.querySelector('.overlay-lvh'),
                dvh: document.querySelector('.overlay-dvh')
            };

            function readViewport() {
                const innerH = window.innerHeight || 0;
                const clientH = document.documentElement.clientHeight || 0;
                const vview = window.visualViewport;
                const vH = vview ? Math.round(vview.height) : 'n/a';
                const vTop = vview ? Math.round(vview.offsetTop) : 'n/a';
                document.getElementById('innerH').textContent = innerH;
                document.getElementById('clientH').textContent = clientH;
                document.getElementById('vviewH').textContent = vH;
                document.getElementById('vviewTop').textContent = vTop;
            }

            function updatePanels() {
                // update each panel metrics
                panels.forEach((panel, i) => {
                    const elemHeight = panel.offsetHeight;
                    const rectH = Math.round(panel.getBoundingClientRect().height);
                    panel.querySelector('.elem-height').textContent = elemHeight;
                    panel.querySelector('.rect-height').textContent = rectH;
                });
            }

            function updateOverlays() {
                // Position fixed overlays so they sit above the bottom browser UI (address/tool bar)
                panels.forEach((panel) => {
                    const rect = panel.getBoundingClientRect();
                    const unit = panel.getAttribute('data-unit');
                    const overlay = overlays[unit];
                    if (!overlay) return;
                    // align overlay horizontally with the panel
                    overlay.style.left = Math.max(0, rect.left) + 'px';
                    overlay.style.width = rect.width + 'px';
                    // Compute bottom offset so overlay sits above bottom browser UI.
                    // bottomUI = window.innerHeight - (visualViewport.offsetTop + visualViewport.height)
                    const vview = window.visualViewport;
                    const bottomUI = vview ? Math.max(0, Math.round(window.innerHeight - (vview.offsetTop + vview.height))) : 0;
                    // Place overlay immediately above the bottom UI (so it appears 'on top' of content, above address bar)
                    overlay.style.bottom = bottomUI + 'px';
                });
            }

            // 合成: 1フレームでまとめて更新
            function refreshAll() {
                readViewport();
                updatePanels();
                updateOverlays();
            }

            // Event bindings: resize/scroll/orientationおよび visualViewport のイベントを監視
            window.addEventListener('load', () => requestAnimationFrame(refreshAll));
            window.addEventListener('resize', () => requestAnimationFrame(refreshAll));
            window.addEventListener('scroll', () => requestAnimationFrame(refreshAll));
            window.addEventListener('orientationchange', () => requestAnimationFrame(refreshAll));
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => requestAnimationFrame(refreshAll));
                window.visualViewport.addEventListener('scroll', () => requestAnimationFrame(refreshAll));
            }

            // 少しの間隔で監視して、iOS の UI 変化を確実に捕まえる
            let tick = 0;
            setInterval(() => {
                if (++tick % 5 === 0) requestAnimationFrame(refreshAll);
            }, 250);
        })();
    </script>
</body>
</html>