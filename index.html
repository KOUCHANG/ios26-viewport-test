<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS 26 Viewport Horizontal Comparison</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <main>
        <section class="intro">
            <div id="commit-hash">commit: b1a8648</div>
            <h1>iOS 26 ビューポート単位 比較デモ</h1>
            <p>下にスクロールして、ブラウザのアドレスバーの表示/非表示を切り替えてください。<br>
            各カラムはそれぞれ <code>100vh</code> / <code>100lvh</code> / <code>100dvh</code> を使って高さを決めています。</p>
            <p>右上の数値は実際のピクセル高さおよびビューポート API の値です。iOS 26 での挙動を観察してください。</p>
        </section>

        <div class="container">
            <div class="panel-simple">
                <h2>Fixed bar behavior test</h2>
                <p>下の固定バー内のテキストボックスをタップして、キーボード出現時の位置の変化を確認してください。</p>
                <p>このページは固定バーの挙動に集中するため、vh/lvh/dvh の比較要素は削除しました。</p>
            </div>
        </div>


        <!-- fixed bottom bar for keyboard testing (moved to body root for iOS fixed behavior) -->
        <div class="scroll-filler">
            <p>↓ スクロールしてアドレスバーの表示/非表示を切り替えてください ↓</p>
        </div>
    </main>

    <aside class="status">
        <h3>ビューポート情報</h3>
        <div>window.innerHeight: <strong id="innerH">--</strong>px</div>
        <div>visualViewport.height: <strong id="vviewH">--</strong>px</div>
        <div>visualViewport.offsetTop: <strong id="vviewTop">--</strong>px</div>
    </aside>

    <div id="fixed-bar" role="dialog" aria-label="固定バー">
        <div class="input-wrap">
            <input id="test-input" type="text" placeholder="ここをタップしてキーボードを出してみてください" autocomplete="off">
        </div>
    </div>

    <script>
        // ヘルパー: DOM を更新して各パネルとオーバーレイの位置・高さを表示/調整
        (function () {
            const panels = Array.from(document.querySelectorAll('.column'));
            // overlays will be looked up at runtime inside refreshAll
            let overlaysRoot = null;
            let overlays = {};

            function readViewport() {
                const innerH = window.innerHeight || 0;
                const clientH = document.documentElement.clientHeight || 0;
                const vview = window.visualViewport;
                const vH = vview ? Math.round(vview.height) : 'n/a';
                const vTop = vview ? Math.round(vview.offsetTop) : 'n/a';
                document.getElementById('innerH').textContent = innerH;
                document.getElementById('clientH').textContent = clientH;
                document.getElementById('vviewH').textContent = vH;
                document.getElementById('vviewTop').textContent = vTop;
                return {innerH, clientH, vH, vTop, vview};
            }

            function updatePanels(vinfo) {
                // Set heights explicitly only on mobile or platforms with unstable CSS viewport units.
                const {innerH, vH, vview} = vinfo;
                const visualH = (vview && vview.height) ? vview.height : innerH;
                const lvh = Math.max(innerH, visualH);

                // Detect mobile / small-screen environments; use JS sizing when viewport is narrow or touch device
                const ua = navigator.userAgent || '';
                const isMobileUA = /iP(hone|ad|od)|Android/.test(ua) && !/Windows/.test(ua);
                const isTouch = !!(navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
                const needsJsSizing = (window.innerWidth <= 800) || isMobileUA || (isTouch && window.innerWidth <= 1024);

                if (needsJsSizing) {
                    panels.forEach((panel) => {
                        const unit = panel.getAttribute('data-unit');
                        if (unit === 'vh') {
                            panel.style.height = innerH + 'px';
                        } else if (unit === 'lvh') {
                            panel.style.height = lvh + 'px';
                        } else if (unit === 'dvh') {
                            panel.style.height = Math.round(visualH) + 'px';
                        }
                        const elemHeight = panel.offsetHeight;
                        const rectH = Math.round(panel.getBoundingClientRect().height);
                        panel.querySelector('.elem-height').textContent = elemHeight;
                        panel.querySelector('.rect-height').textContent = rectH;
                    });
                } else {
                    // Desktop browsers: prefer CSS (clear any JS-set heights)
                    panels.forEach((panel) => {
                        panel.style.height = '';
                        const elemHeight = panel.offsetHeight;
                        const rectH = Math.round(panel.getBoundingClientRect().height);
                        panel.querySelector('.elem-height').textContent = elemHeight;
                        panel.querySelector('.rect-height').textContent = rectH;
                    });
                }
            }

            function updateOverlays(vinfo) {
                const {vview} = vinfo;
                const safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom')) || 0;
                const container = document.querySelector('.container');
                const containerRect = container.getBoundingClientRect();
                panels.forEach((panel, idx) => {
                    const unit = panel.getAttribute('data-unit');
                    const overlay = overlays[unit];
                    if (!overlay) return;
                    // compute left relative to viewport using container scroll and panel.offsetLeft
                    const offsetLeft = panel.offsetLeft || 0;
                    const left = Math.round(containerRect.left + offsetLeft - (container.scrollLeft || 0));
                    const width = Math.min(panel.offsetWidth || panel.getBoundingClientRect().width || window.innerWidth, window.innerWidth);
                    overlay.style.left = Math.max(0, left) + 'px';
                    overlay.style.width = Math.max(80, width) + 'px';
                    overlay.style.display = 'block';
                });
                // compute bottom gap (space occupied by browser UI)
                const bottomUI = vview ? Math.max(0, Math.round(window.innerHeight - (vview.offsetTop + vview.height))) : 0;
                const bottomValue = (bottomUI + (window.safeAreaInsetBottom || safeBottom));
                Object.values(overlays).forEach(o => { if (o) o.style.bottom = bottomValue + 'px'; });
            }

            // ヘルパー: 固定バーを visualViewport に追従させる簡易スクリプト
            (function () {
                const bar = document.getElementById('fixed-bar');
                function updateBar() {
                    const vview = window.visualViewport;
                    const safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom')) || 0;
                    const bottomUI = vview ? Math.max(0, Math.round(window.innerHeight - (vview.offsetTop + vview.height))) : 0;
                    const bottomValue = bottomUI + (window.safeAreaInsetBottom || safeBottom);
                    if (bar) bar.style.bottom = bottomValue + 'px';
                    // update status
                    if (document.getElementById('innerH')) document.getElementById('innerH').textContent = window.innerHeight;
                    if (document.getElementById('vviewH')) document.getElementById('vviewH').textContent = vview ? Math.round(vview.height) : 'n/a';
                    if (document.getElementById('vviewTop')) document.getElementById('vviewTop').textContent = vview ? Math.round(vview.offsetTop) : 'n/a';
                }

                window.addEventListener('resize', updateBar);
                window.addEventListener('orientationchange', updateBar);
                window.addEventListener('scroll', updateBar);
                if (window.visualViewport) {
                    window.visualViewport.addEventListener('resize', updateBar);
                    window.visualViewport.addEventListener('scroll', updateBar);
                }
                // initial
                setTimeout(updateBar, 200);
            })();
        })();