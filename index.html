<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>iOS 26 Viewport Horizontal Comparison</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>

    <main>
        <section class="intro">
            <div id="commit-hash">commit: cbd52a2</div>
            <h1>iOS 26 ビューポート単位 比較デモ</h1>
            <p>下にスクロールして、ブラウザのアドレスバーの表示/非表示を切り替えてください。<br>
            各カラムはそれぞれ <code>100vh</code> / <code>100lvh</code> / <code>100dvh</code> を使って高さを決めています。</p>
            <p>右上の数値は実際のピクセル高さおよびビューポート API の値です。iOS 26 での挙動を観察してください。</p>
        </section>

        <div class="container">
            <div class="column vh-unit" data-unit="vh">
                <div class="panel-body">
                    <div class="panel-header">100vh</div>
                    <div class="panel-note">従来のビューポート高さ (vh)</div>
                    <div class="metrics">
                        <div>要素高さ: <strong><span class="elem-height">--</span>px</strong></div>
                        <div>getBoundingClientRect: <strong><span class="rect-height">--</span>px</strong></div>
                    </div>
                </div>
            </div>

            <div class="column lvh-unit" data-unit="lvh">
                <div class="panel-body">
                    <div class="panel-header">100lvh</div>
                    <div class="panel-note">ラージ・ビューポート高さ (lvh)</div>
                    <div class="metrics">
                        <div>要素高さ: <strong><span class="elem-height">--</span>px</strong></div>
                        <div>getBoundingClientRect: <strong><span class="rect-height">--</span>px</strong></div>
                    </div>
                </div>
            </div>

            <div class="column dvh-unit" data-unit="dvh">
                <div class="panel-body">
                    <div class="panel-header">100dvh</div>
                    <div class="panel-note">ダイナミック・ビューポート高さ (dvh)</div>
                    <div class="metrics">
                        <div>要素高さ: <strong><span class="elem-height">--</span>px</strong></div>
                        <div>getBoundingClientRect: <strong><span class="rect-height">--</span>px</strong></div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 固定オーバーレイ（アドレスバー上に見える予定の領域を再現） -->
        <div class="overlays-wrapper" aria-hidden="true">
            <div id="overlays">
                <div class="overlay overlay-vh">固定バー (下部・vh)</div>
                <div class="overlay overlay-lvh">固定バー (下部・lvh)</div>
                <div class="overlay overlay-dvh">固定バー (下部・dvh)</div>
            </div>
        </div>

        <div class="scroll-filler">
            <p>↓ スクロールしてアドレスバーの表示/非表示を切り替えてください ↓</p>
        </div>
    </main>

    <aside class="status">
        <h3>ビューポート情報</h3>
        <div>window.innerHeight: <strong id="innerH">--</strong>px</div>
        <div>document.documentElement.clientHeight: <strong id="clientH">--</strong>px</div>
        <div>visualViewport.height: <strong id="vviewH">--</strong>px</div>
        <div>visualViewport.offsetTop: <strong id="vviewTop">--</strong>px</div>
    </aside>

    <script>
        // ヘルパー: DOM を更新して各パネルとオーバーレイの位置・高さを表示/調整
        (function () {
            const panels = Array.from(document.querySelectorAll('.column'));
            const overlays = {
                vh: document.querySelector('.overlay-vh'),
                lvh: document.querySelector('.overlay-lvh'),
                dvh: document.querySelector('.overlay-dvh')
            };

            function readViewport() {
                const innerH = window.innerHeight || 0;
                const clientH = document.documentElement.clientHeight || 0;
                const vview = window.visualViewport;
                const vH = vview ? Math.round(vview.height) : 'n/a';
                const vTop = vview ? Math.round(vview.offsetTop) : 'n/a';
                document.getElementById('innerH').textContent = innerH;
                document.getElementById('clientH').textContent = clientH;
                document.getElementById('vviewH').textContent = vH;
                document.getElementById('vviewTop').textContent = vTop;
                return {innerH, clientH, vH, vTop, vview};
            }

            function updatePanels(vinfo) {
                // Set heights explicitly only on mobile or platforms with unstable CSS viewport units.
                const {innerH, vH, vview} = vinfo;
                const visualH = (vview && vview.height) ? vview.height : innerH;
                const lvh = Math.max(innerH, visualH);

                // Detect mobile devices (iOS/Android) strictly; only then apply JS sizing.
                const ua = navigator.userAgent || '';
                const isMobile = /iP(hone|ad|od)|Android/.test(ua) && !/Windows/.test(ua);
                const needsJsSizing = isMobile;

                if (needsJsSizing) {
                    panels.forEach((panel) => {
                        const unit = panel.getAttribute('data-unit');
                        if (unit === 'vh') {
                            panel.style.height = innerH + 'px';
                        } else if (unit === 'lvh') {
                            panel.style.height = lvh + 'px';
                        } else if (unit === 'dvh') {
                            panel.style.height = Math.round(visualH) + 'px';
                        }
                        const elemHeight = panel.offsetHeight;
                        const rectH = Math.round(panel.getBoundingClientRect().height);
                        panel.querySelector('.elem-height').textContent = elemHeight;
                        panel.querySelector('.rect-height').textContent = rectH;
                    });
                } else {
                    // Desktop browsers: prefer CSS (clear any JS-set heights)
                    panels.forEach((panel) => {
                        panel.style.height = '';
                        const elemHeight = panel.offsetHeight;
                        const rectH = Math.round(panel.getBoundingClientRect().height);
                        panel.querySelector('.elem-height').textContent = elemHeight;
                        panel.querySelector('.rect-height').textContent = rectH;
                    });
                }
            }

            function updateOverlays(vinfo) {
                // Position fixed overlays so they sit above the bottom browser UI (address/tool bar)
                const {vview} = vinfo;
                // compute safe-area bottom
                const safeBottom = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--safe-bottom')) || 0;
                panels.forEach((panel) => {
                    const rect = panel.getBoundingClientRect();
                    const unit = panel.getAttribute('data-unit');
                    const overlay = overlays[unit];
                    if (!overlay) return;
                    // align overlay horizontally with the panel
                    overlay.style.left = Math.max(0, rect.left) + 'px';
                    overlay.style.width = rect.width + 'px';
                    // Determine bottom offset: visualViewport bottom gap + safe-area
                    const bottomUI = vview ? Math.max(0, Math.round(window.innerHeight - (vview.offsetTop + vview.height))) : 0;
                    overlay.style.bottom = (bottomUI + (window.safeAreaInsetBottom || safeBottom)) + 'px';
                });
            }

            // 合成: 1フレームでまとめて更新
            function refreshAll() {
                const vinfo = readViewport();
                updatePanels(vinfo);
                updateOverlays(vinfo);
            }

            // Event bindings: resize/scroll/orientationおよび visualViewport のイベントを監視
            window.addEventListener('load', () => requestAnimationFrame(refreshAll));
            window.addEventListener('resize', () => requestAnimationFrame(refreshAll));
            window.addEventListener('scroll', () => requestAnimationFrame(refreshAll));
            window.addEventListener('orientationchange', () => requestAnimationFrame(refreshAll));
            if (window.visualViewport) {
                window.visualViewport.addEventListener('resize', () => requestAnimationFrame(refreshAll));
                window.visualViewport.addEventListener('scroll', () => requestAnimationFrame(refreshAll));
            }

            // 少しの間隔で監視して、iOS の UI 変化を確実に捕まえる
            let tick = 0;
            setInterval(() => {
                if (++tick % 5 === 0) requestAnimationFrame(refreshAll);
            }, 250);
        })();
    </script>
</body>
</html>